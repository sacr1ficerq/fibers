|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem sm12-5: cxx/concurrency/fibers

[Реализуйте](https://gist.github.com/ObjatieGroba/f197c54e2f7aa54ecb4d582e3dacf784) функции
помеченные TODO так, чтобы тесты прошли.

Yield переключает выполнение на другую нить если такая нить существует.

Используйте уже реализованную run_fiber запуска функции.

FiberKeeper (std::function) содержит нетривиальный конструктор и деструктор. Используйте memcpy и
memset чтобы избежать двойного вызова деструктора и передать аргумент внутрь файбера.

Метод switch_context меняет местами текущее исполнение и "сохраненное" в структуре.

Обратите внимание что run_fiber принимает на самом деле (по C++ decl) указатель на fiber, а не саму
структуру. Тем не менее советую положить структуру рядом.

switch_context должен сохранять все необходимые регистры и при переключении, но в самой структуре
нет необходимости в иных полях.

Тесты и функция main в тестирующей системе не отличаются кроме теста `test_secret`, тело которого
вам неизвестно.

Для использования меток внутри inline asm [ссылка](https://stackoverflow.com/a/16095781).

Обратите внимание на InlineScheduler запускающий файберы незамедлительно. Этот планировщик проходит
несколько тестов.

Ваш код будет скомпилирован с флагом `-O2`

В качестве ответа необходимо прислать только реализации функций:

    
    
    void FiberScheduler::Context::switch_context() {
        ...
    }
    
    void FiberScheduler::schedule(Fiber fiber) {
        ...
    }
    
    void FiberScheduler::yield() {
        ...
    }
    
    void FiberScheduler::run() {
        ...
    }
        

